module cfs/Expressions

imports
	lex/Identifier
	lex/Number
	lex/Text
	cfs/Names
	cfs/Values
	cfs/Types
	cfs/Patterns

context-free start-symbols
	Expr
	SimpleMatching
	MultipleMatching
	LetBinding

template options
	keyword -/- [A-Za-z]
	

templates
	RecordBinding2.RecordBinding = [[GLOBALNAME] = [Expr]]
	TupleList2.TupleList = [[Expr], [Expr+; separator=","]]
	
	//this is probably a mistake in the manual because it isn't explained and it's ambiguous with Variable
	// Expr.Ident               = [[IDENT]]
	//prefer variable over constant because a constant with a name can probably be resolved as a variable?
	Expr.VariableExpr   = [[Variable]] {prefer}
	Expr.ConstantExpr   = [[Constant]]
	Expr                = [([Expr])] {bracket}
	Expr                = [begin [Expr] end] {bracket}
	Expr.TypeConstraint = [([Expr] : [TypeExpr])]
	Expr.TupleExpr      = [[TupleList2]]
	//ambiguous with function application, and not really different
	// Expr.ConstructorExpr     = [[NCConstr] [Expr]]
	Expr.ConsExpr     = [[Expr] :: [Expr]]{right}
	Expr.ListLiteral  = <[<Expr+; separator=";">]>
	Expr.ArrayLiteral = <[|<Expr+; separator=";">|]>
	Expr.RecordExpr   = [{[RecordBinding2+; separator=";"]}]
	Expr.FunctionApp  = [[Expr] [Expr]] {left}
	Expr.RecordAccess = [[Expr].[GLOBALNAME]]
	Expr.RecordAssign = [[Expr].[GLOBALNAME] <- [Expr]] {right}
	Expr.ArrayAccess  = [[Expr].([Expr])] 
	Expr.ArrayAssign  = [[Expr].([Expr]) <- [Expr]] {right}
	Expr.LogicalAnd   = [[Expr] & [Expr]] {left}
	Expr.LogicalOr    = [[Expr] or [Expr]] {left}
	Expr.IfExpr       = [if [Expr] then [Expr]] {prefer}
	Expr.IfExpr       = [if [Expr] then [Expr] else [Expr]]
	Expr.WhileExpr    = [while [Expr] do [Expr] done]
	Expr.ForExpr      = [for [IDENT] = [Expr] to [Expr] do [Expr] done]
	Expr.ForExpr      = [for [IDENT] = [Expr] downto [Expr] do [Expr] done]
	// ambiguous with expressions in list and array literals
	Expr.ExprSequence = [[Expr] ; [Expr]] {avoid}
	Expr.MatchExpr    = [match [Expr] with [SimpleMatching]]
	Expr.FunctionDef  = [fun [MultipleMatching]]
	Expr.FunctionDef  = [function [SimpleMatching]]
	Expr.TryExpr      = [try [Expr] with [SimpleMatching]]
	Expr.LetExpr      = [let [LetBinding+; separator="and"] in [Expr]]
	Expr.LetRecExpr   = [let rec [LetBinding+; separator="and"] in [Expr]]
	
	Matching1.Matching1               = [[Pattern] -> [Expr]]
	MatchingMore.MatchingMore         = [[Pattern+] -> [Expr]]
	SimpleMatching.SimpleMatching     = [[Matching1+; separator="|"]]
	MultipleMatching.MultipleMatching = [[MatchingMore+; separator="|"]]
	LetBinding.LetBinding             = [[Pattern] = [Expr]]
	LetBinding.LetBinding             = [[Variable] [Pattern+] = [Expr]]
	
	// avoid in favour of negative integer literals
	Expr.Negate        = [-[Expr]] {avoid}
	Expr.FloatNegate   = [-.[Expr]]
	Expr.Dereference   = [![Expr]]
	Expr.Add           = [[Expr] + [Expr]] {left}
	Expr.Subtract      = [[Expr] - [Expr]] {left}
	Expr.Multiply      = [[Expr] * [Expr]] {left}
	Expr.Division      = [[Expr] / [Expr]] {left}
	Expr.Modulo        = [[Expr] mod [Expr]] {left}
	Expr.FloatAdd      = [[Expr] +. [Expr]] {left}
	Expr.FloatSubtract = [[Expr] -. [Expr]] {left}
	Expr.FloatMultiply = [[Expr] *. [Expr]] {left}
	Expr.FloatDivision = [[Expr] /. [Expr]] {left}
	Expr.FloatPowerOf  = [[Expr] ** [Expr]] {right}
	Expr.ListConcat    = [[Expr] @ [Expr]] {right}
	Expr.StringConcat  = [[Expr] ^ [Expr]] {right}
	//this one isn't explained in the manual!
	Expr.UndefinedOperator = [[Expr] ! [Expr]]
	Expr.ReferenceAssign   = [[Expr] := [Expr]] {right}
	
	Expr.StructuralEquals       = [[Expr] = [Expr]] {left}
	Expr.StructuralInequals     = [[Expr] <> [Expr]] {left}
	Expr.PhysicalEquals         = [[Expr] == [Expr]] {left}  
	Expr.PhysicalInequals       = [[Expr] != [Expr]] {left}  
	Expr.LessThan               = [[Expr] < [Expr]] {left}
	Expr.LessThanEquals         = [[Expr] <= [Expr]] {left}
	Expr.GreaterThan            = [[Expr] > [Expr]] {left}
	Expr.GreaterThanEquals      = [[Expr] >= [Expr]] {left}
	Expr.FloatLessThan          = [[Expr] <. [Expr]] {left} 
	Expr.FloatLessThanEquals    = [[Expr] <=. [Expr]] {left}
	Expr.FloatGreaterThan       = [[Expr] >. [Expr]] {left} 
	Expr.FloatGreaterThanEquals = [[Expr] >=. [Expr]] {left}

context-free priorities
	Expr.Dereference > {
		Expr.RecordAccess
		Expr.ArrayAccess
	} >
	Expr.FunctionApp > {
		Expr.Negate
		Expr.FloatNegate
	} >
	Expr.FloatPowerOf >
	Expr.Modulo > {
		Expr.Multiply
		Expr.FloatMultiply
		Expr.Division
		Expr.FloatDivision
	} > {
		Expr.Add
		Expr.FloatAdd
		Expr.Subtract
		Expr.FloatSubtract
	} >
	Expr.ConsExpr > {
		Expr.ListConcat
		Expr.StringConcat
	} > {
		Expr.StructuralEquals   
		Expr.StructuralInequals 
		Expr.PhysicalEquals     
		Expr.PhysicalInequals   
		Expr.LessThan           
		Expr.LessThanEquals   
		Expr.GreaterThan        
		Expr.GreaterThanEquals
		Expr.FloatLessThan      
		Expr.FloatLessThanEquals   
		Expr.FloatGreaterThan        
		Expr.FloatGreaterThanEquals
	} >
	//TODO: find out where the not is that the manual names in the table?
	// Expr.Not >
	Expr.LogicalAnd >
	Expr.LogicalOr >
	Expr.TupleExpr > {
		Expr.RecordAssign
		Expr.ArrayAssign
		Expr.ReferenceAssign
	} >
	Expr.IfExpr >
	Expr.ExprSequence > {
		Expr.LetExpr     
		Expr.LetRecExpr  
		Expr.MatchExpr   
		Expr.FunctionDef 
		Expr.TryExpr     
	}