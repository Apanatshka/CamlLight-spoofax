module analysis/constraints

imports
  include/CamlLight
  extra-constructors
  runtime/nabl/uri

signature
  constructors
    TypeScheme : List(TYPEVARIABLE) * Constraint * TypeExpr -> TypeScheme
    
    CTrue   : Constraint
    CFalse  : Constraint
    CPred   : ConstraintPredicate * List(TypeExpr) -> Constraint
    CAnd    : List(Constraint) -> Constraint
    CExist  : List(TYPEVARIABLE) * Constraint -> Constraint
    CDef    : /* NaBL- */ URI * TypeScheme * Constraint -> Constraint
    CInst   : /* NaBL- */ URI * TypeScheme -> Constraint
    
    CEq  : ConstraintPredicate
    CSub : ConstraintPredicate

strategies
	fresh-var = !TypeVar(<newname> "TV") // : TYPEVARIABLE
	
	typescheme: (tv*, c, te) -> TypeScheme(tv*, c,       te)
	typescheme: (tv*,    te) -> TypeScheme(tv*, <cTrue>, te)
  typescheme: (        te) -> TypeScheme([],  <cTrue>, te)
	
	cTrue  = !CTrue()
	cFalse = !CFalse()
	cPred:  (pred, te*)  -> CPred(pred, te*)
	cAnd:    c*          -> CAnd(c*)
	cExist: (tv*, c)     -> CExist(tv*, c)
	cDef:   (uri, ts, c) -> CDef(uri, ts, c)
	cInst:  (uri, ts)    -> CInst(uri, ts)
	
  cEq:       te*                           -> <cPred> (CEq(), te*)
  cInst':   (TypeScheme(tv*, c, te1), te2) -> <cExist> (tv*, <cAnd> [c, <cEq> (te1, te2)])
  cHasInst:  TypeScheme(tv*, c, te)        -> <cExist> (tv*, c)
  cLet:     (uri, ts, c)                   -> <cAnd> [<cHasInst> ts, <cDef>]
  
strategies
	consecutive-pairs(s) = Dupl;(id,Tl<+![]);zipr(s)
	
  multi-lookup(|l): n -> <filter(?(n,_));map(Snd)> l
  keys = map(Fst);make-set
  
  min-length(|len): list -> list
    where <length;!(<id>,len);geq> list
  
  is-effective(s): term -> result
    where result := <s> term
        ; <not(eq)>(term,result)
  
  fixpoint(s): a -> b
    where b := <is-effective(s);fixpoint(s) <+ !a> a
    
  scanfix(s): a -> b
    where b := <is-effective(s);\c -> [c | <fixpoint(s)> c]\ <+ ![a]> a
  
  empty-isect = isect;?[]
  empty-isect(|one*) = ?other*;!(one*,other*);empty-isect
  
  ftv = free-vars(?TypeVar(_), {\CExist(xs, _) -> xs\})
  
  getfirst-split(s): ([h|t], l*) -> (<s> h, [<reverse> l*, t])
  getfirst-split(s): ([h|t], l*) -> <getfirst-split(s)> (t, [<not(s)> h | l*])

  extendUp(s) = Dupl;(id,s)

  ndet-list-binop(s): l -> l'
    where repl* := <join(extendUp(s));not(?[])> l
        ; l' := <foldl(ndet-list-binop-helper)> (repl*, l)
  ndet-list-binop-helper: (((a,b),c),l) -> l''
    where l'  := <split-fetch(?a);conc> l
        ; l'' := <split-fetch(?b);(id,![c|<id>]);conc> l'
