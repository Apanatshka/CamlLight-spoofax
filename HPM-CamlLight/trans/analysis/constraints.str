module analysis/constraints

imports
  include/CamlLight
  extra-constructors
  runtime/nabl/uri

signature
  constructors
    TypeScheme : List(TYPEVARIABLE) * Constraint * TypeExpr -> TypeScheme
    
    CTrue   : Constraint
    CFalse  : Constraint
    CPred   : ConstraintPredicate * List(TypeExpr) -> Constraint
    CAnd    : List(Constraint) -> Constraint
    CExist  : List(TYPEVARIABLE) * Constraint -> Constraint
    CDef    : /* NaBL- */ URI * TypeScheme * Constraint -> Constraint
    CInst   : /* NaBL- */ URI * TypeScheme -> Constraint
    
    CEq  : ConstraintPredicate
    CSub : ConstraintPredicate

strategies
  multi-eq-to-eq(eq) = !(<id>,<Tl <+ ![]>);zipr(eq)
  
	fresh-var = !TypeVar(<newname> "TV") // : TYPEVARIABLE
	
	typescheme: (tv*, c, te) -> TypeScheme(tv*, c,       te)
	typescheme: (tv*,    te) -> TypeScheme(tv*, <cTrue>, te)
  typescheme: (        te) -> TypeScheme([],  <cTrue>, te)
	
	cTrue  = !CTrue()
	cFalse = !CFalse()
	cPred:  (pred, te*)  -> CPred(pred, te*)
	cAnd:    c*          -> CAnd(c*)
	cExist: (tv*, c)     -> CExist(tv*, c)
	cDef:   (uri, ts, c) -> CDef(uri, ts, c)
	cInst:  (uri, ts)    -> CInst(uri, ts)
	
  cEq:       te*                           -> <cPred> (CEq(), te*)
  cInst':   (TypeScheme(tv*, c, te1), te2) -> <cExist> (tv*, <cAnd> [c, <cEq> (te1, te2)])
  cHasInst:  TypeScheme(tv*, c, te)        -> <cExist> (tv*, c)
  cLet:     (uri, ts, c)                   -> <cAnd> [<cHasInst> ts, <cDef>]
  
strategies
  multi-lookup(|l): n -> <filter(?(n,_));map(Snd)> l
  keys = map(Fst);make-set
  
  min-length(|len): list -> list
    where <length;!(<id>,len);geq> list
  
  is-effective(s): term -> result
    where result := <s> term
        ; <not(eq)>(term,result)
  
  fixpoint(s): a -> b
    where b := <is-effective(s);fixpoint(s) <+ !a> a
    
  scanfix(s): a -> b
    where b := <is-effective(s);\c -> [c | <fixpoint(s)> c]\ <+ ![a]> a