module analysis/constraints

imports
  include/CamlLight
  extra-constructors

signature
  constructors
    CEq     : TypeExpr * TypeExpr -> Constraint
    CMEq    : List(TypeExpr) -> Constraint

strategies
	fresh-var = !TypeVar(<newname> "TV")
	
	mkCEq = !CEq(<Fst>, <Snd>)
  mkCMEq = !CMEq(<id>)
  
  CEqTuple: CEq(a,b) -> (a,b)
  
  typevar-first = try(\CEq(a, b@TypeVar(_)) -> CEq(b, a) where <not(?TypeVar(_))> a\)
  
strategies
  multi-eq-to-eq(eq) = !(<id>,<Tl <+ ![]>);zipr(eq)
  
  multi-lookup(|l): n -> <filter(?(n,_));map(Snd)> l
  keys = map(Fst);make-set
  
  min-length(|len): list -> list
    where <length;!(<id>,len);geq> list
  
  is-effective(s): term -> result
    where result := <s> term
        ; <not(eq)>(term,result)
  
  fixpoint(s): a -> b
    where b := <is-effective(s);fixpoint(s) <+ !a> a
    
  scanfix(s): a -> b
    where b := <is-effective(s);\c -> [c | <fixpoint(s)> c]\ <+ ![a]> a
    
strategies
	nonmatching(impenetrable): (t1,t2) -> <zip(nonmatching(impenetrable));concat> (tp1*,tp2*)
	  where <not(impenetrable)> t1
	      ; <not(impenetrable)> t2
	      ; tc#(tp1*) := t1
	      ; tc#(tp2*) := t2
	
	nonmatching(impenetrable): (t1,t2) -> [<id>]
    where <impenetrable> t1
  
  nonmatching(impenetrable): (t1,t2) -> [<id>]
    where <impenetrable> t2