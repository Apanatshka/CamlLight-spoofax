module analysis/constraints

imports
  include/CamlLight
  extra-constructors

signature
  constructors
    CEq     : TypeExpr * TypeExpr -> Constraint
    CMEq    : List(TypeExpr) -> Constraint

strategies
  // note that this strategy creates a type variable with *two* apostrophes in front of it to show that it is generated
	fresh-var = !TypeVar(<conc-strings>("''", <newname> "t"))
	
	mkCEq = !CEq(<Fst>, <Snd>)
  mkCMEq = !CMEq(<id>)
  
  typevar-first = try(\CEq(a, b@TypeVar(_)) -> CEq(b, a) where <not(?TypeVar(_))> a\)
  
strategies
  tails: [] -> []
  tails: l@[h|t] -> [l | <tails> t]
  
  multi-eq-to-eq(eq) = tails;mapconcat({\[h|t] -> <map(<eq>(h,<id>))> t\})
  
  multi-lookup(|l): n -> <filter(?(n,_));map(Snd)> l
  keys = map(Fst);make-set
  
  min-length(|len): list -> list
    where <length;!(<id>,len);geq> list
  
  //fixpoint(s) = try(s);(?<id> < id + fixpoint(s))
  fixpoint(s): a -> c
    where b := <s> a
        ; (!a => b < c := a + c := <fixpoint(s)> b)