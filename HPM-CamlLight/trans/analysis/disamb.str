module trans/analysis/disamb

imports
  include/CamlLight
  runtime/nabl/-
  trans/analysis/names
  trans/extra-constructors

// Code to disambiguate the purposely ambiguous grammar using information from the name analysis

rules
	
  disamb: amb(l@[CConstr(_), Var(_)]) -> <disamb> amb(<reverse> l)
  disamb: amb([v@Var(vn), c@CConstr(cn)]) -> res
  with if <nabl-uri;nabl-uri-namespace> cn
         then res := c
         else res := v
       end
  
  disamb: amb(l@[CConstr(_), PatternVar(_)]) -> <disamb> amb(<reverse> l)
  disamb: amb([v@PatternVar(vn), c@CConstr(cn)]) -> res
  with if <nabl-uri;nabl-uri-namespace> cn
         then res := c
         else res := v
       end
  
  // how is it going to be useful to discriminate function and constructor applications?
  disamb: amb(l@[ConstrApp(_,_), FuncApp(_,_)]) -> <disamb> amb(<reverse> l)
  disamb: amb([fa@FuncApp(f, farg), ca@ConstrApp(c, carg)]) -> res
  with if <?NCConstr(cn)> f; <nabl-uri;nabl-uri-namespace> cn
         then res := ca
         else res := fa
       end
  
  disamb: amb([cl, l]) -> l
  where cn := <getfirst(?ConstrPattern(NCConstr(<id>),_))> cl
      ; <not(nabl-uri;nabl-uri-namespace)> cn
  disamb: amb([l, cl]) -> l
  where cn := <getfirst(?ConstrPattern(NCConstr(<id>),_))> cl
      ; <not(nabl-uri;nabl-uri-namespace)> cn
  
  // remove nested lists that may be left behind after clearing the amb()
  post-disamb = GlobalFunDef(id,flatten-list,id)
              + LocalFunDef(id,flatten-list,id)
              + GlobalRecFunDef(id,flatten-list,id)
              + LocalRecFunDef(id,flatten-list,id)
  
  disamb-all = bottomup(try(disamb));topdown(try(post-disamb))
             ; not(getfirst(?amb(_))) // safety check that all amb() are removed
