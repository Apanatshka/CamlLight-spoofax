module analysis/collect-constraints

imports
  include/CamlLight
  extra-constructors
  analysis/constraints
  lib/runtime/nabl/-
  lib/runtime/analysis/-
  lib/runtime/task/-
  lib/runtime/types/-

strategies
  collect-constraint: GlobalFunDef(name, param*, body) ->
      ((<try(name-resolve)> name, name-ty), c)
      where param-tv* := <map(fresh-var)> param*
          ; result-tv := <fresh-var>
          ; name-tv   := <fresh-var>
          ; name-ty   := <foldr(!result-tv, !FuncType(<Fst>, <Snd>))> param-tv*
          ; name-c    := <cEq> [name-ty, name-tv]
          ; result-c  := <collect-constraint> (body, result-tv)
          ; param'*   := <zip> (<map({\PatternVar(gn) -> gn\};try(name-resolve))> param*, param-tv*)
          ; c-let     := <foldr(!result-c, !(<Fst;Fst>, <Fst;Snd;typescheme>, <Snd>);cLet)> param'*
          ; c := <cExist> (<conc> (param-tv*, [result-tv]), c-let)
  
  collect-constraint: GlobalRecFunDef(name, param*, body) ->
      ((<try(name-resolve)> name, name-ty), c)
      where param-tv* := <map(fresh-var)> param*
          ; result-tv := <fresh-var>
          ; name-tv   := <fresh-var>
          ; name-ty   := <foldr(!result-tv, !FuncType(<Fst>, <Snd>))> param-tv*
          ; name-c    := <cEq> [name-ty, name-tv]
          ; result-c  := <collect-constraint> (body, result-tv)
          ; param'*   := <zip> (<map({\PatternVar(gn) -> gn\};try(name-resolve))> param*, param-tv*)
          ; c-let     := <foldr(!result-c, !(<Fst;Fst>, <Fst;Snd;typescheme>, <Snd>);cLet)> param'*
          ; c := <cExist> (<conc> (param-tv*, [result-tv]), c-let)
  
  collect-constraint: (FuncApp(f, a), ty) -> <cAnd> [c1, c2]
    where a-tv := <fresh-var>
        ; f-ty := FuncType(a-tv, ty)
        ; c1   := <collect-constraint> (f,f-ty)
        ; c2   := <collect-constraint> (a,a-tv)
  
  collect-constraint: (IfElseExpr(c,t,e), ty) -> <cAnd> [c1, c2, c3]
    where c-ty := ConstrType(None(), "bool")
        ; c1   := <collect-constraint> (c,c-ty)
        ; c2   := <collect-constraint> (t,ty)
        ; c3   := <collect-constraint> (e,ty)
  
  collect-constraint: (p@Prefix(_), ty) -> <cEq>[ty, <get-type> p]
  
  collect-constraint: (i@Int(_), ty)    -> <cEq>[ty, <get-type> i]
  collect-constraint: (f@Float(_), ty)  -> <cEq>[ty, <get-type> f]
  collect-constraint: (c@Char(_), ty)   -> <cEq>[ty, <get-type> c]
  collect-constraint: (s@String(_), ty) -> <cEq>[ty, <get-type> s]
  collect-constraint: (u@Unit(), ty)    -> <cEq>[ty, <get-type> u]
  
  collect-constraint: (Var(gn), ty) -> <cInst> (<try(name-resolve)> gn, <typescheme> ty)
  
  name-resolve: name -> uri
    where <has-annotation(?Use(u))> name
        ; Def(uri) := <task-get-results; Hd> u
  name-resolve: name -> uri
    where <has-annotation(?Def(uri))> name
  
  collect-constraints: 
    Module(mp*) -> <mapconcat(cc-helper);unzip> mp*
  cc-helper:
  	MP(ValDef(list)) -> <map(collect-constraint)> list
  cc-helper:
    MP(RecValueDef(list)) -> <map(collect-constraint)> list