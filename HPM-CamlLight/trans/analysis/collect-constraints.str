module analysis/collect-constraints

imports
  include/CamlLight
  extra-constructors
  analysis/constraints
  lib/runtime/nabl/-
  lib/runtime/analysis/-
  lib/runtime/task/-
  lib/runtime/types/-

strategies
  collect-constraint: GlobalFunDef(name, params, body) ->
      ([(<try(name-resolve)> name, name-ty), params-n*, body-n*], [params-c*, body-c*])
      where params-ty := <map(fresh-var)> params
          ; body-ty   := <fresh-var>
          ; name-ty   := <foldr(!body-ty, !FuncType(<Fst>, <Snd>))> params-ty
          ; (params-n*,params-c*) := <zip(collect-constraint <+ ());filter(not(?()));unzip;(concat,concat)> (params, params-ty)
          ; (body-n*, body-c*) := <collect-constraint> (body, body-ty)
  // trying same strategy as non-recursive function for now
  collect-constraint: GlobalRecFunDef(name, params, body) ->
      ([(<try(name-resolve)> name, name-ty), params-n*, body-n*], [params-c*, body-c*])
      where params-ty := <map(fresh-var)> params
          ; body-ty   := <fresh-var>
          ; name-ty   := <foldr(!body-ty, !FuncType(<Fst>, <Snd>))> params-ty
          ; (params-n*,params-c*) := <zip(collect-constraint <+ ());filter(not(?()));unzip;(concat,concat)> (params, params-ty)
          ; (body-n*, body-c*) := <collect-constraint> (body, body-ty)
  
  collect-constraint: (PatternVar(name), ty) -> ([(<try(name-resolve)> name, ty)],[])
  
  collect-constraint: (FuncApp(f, a), ty) -> ([n1*,n2*],[c1*,c2*])
    where a-ty := <fresh-var>
        ; f-ty := FuncType(a-ty, ty)
        ; (n1*,c1*) := <collect-constraint> (f,f-ty)
        ; (n2*,c2*) := <collect-constraint> (a,a-ty)
  
  collect-constraint: (IfElseExpr(c,t,e), ty) -> ([n1*,n2*,n3*], [c1*,c2*,c3*])
    where c-ty := ConstrType(None(), "bool")
        ; (n1*,c1*) := <collect-constraint> (c,c-ty)
        ; (n2*,c2*) := <collect-constraint> (t,ty)
        ; (n3*,c3*) := <collect-constraint> (e,ty)
  
  collect-constraint: (p@Prefix(_), ty) -> ([],[CEq(ty, <get-type> p)])
  
  collect-constraint: (i@Int(_), ty)    -> ([],[CEq(ty, <get-type> i)])
  collect-constraint: (f@Float(_), ty)  -> ([],[CEq(ty, <get-type> f)])
  collect-constraint: (c@Char(_), ty)   -> ([],[CEq(ty, <get-type> c)])
  collect-constraint: (s@String(_), ty) -> ([],[CEq(ty, <get-type> s)])
  collect-constraint: (u@Unit(), ty)    -> ([],[CEq(ty, <get-type> u)])
  
  collect-constraint: (Var(gn), ty) -> ([(<name-resolve> gn, ty)], [])
  
  name-resolve: name -> uri
    where <has-annotation(?Use(u))> name
        ; Def(uri) := <task-get-results; Hd> u
  name-resolve: name -> uri
    where <has-annotation(?Def(uri))> name

  constraints-from-names: l -> l''
    where l' := <keys;map(multi-lookup(|l))> l
        ; l'' := <filter(min-length(|2));mapconcat(multi-eq-to-eq(mkCEq))> l'
  
  collect-constraints: 
    Module(mp*) -> (names', constraints')
      where (names, constraints) := <mapconcat(cc-helper)
                           ;unzip
                           ;(concat,concat)> mp*
          ; constraints' := <conc>(<constraints-from-names> names,constraints)
          ; names'       := <keys;map(!(<id>,<lookup>(<id>,names)))> names
  cc-helper:
  	MP(ValDef(list)) -> <map(collect-constraint)> list
  cc-helper:
    MP(RecValueDef(list)) -> <map(collect-constraint)> list