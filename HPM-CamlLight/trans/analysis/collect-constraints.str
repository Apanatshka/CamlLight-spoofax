module analysis/collect-constraints

imports
  include/CamlLight
  extra-constructors
  analysis/constraints
  lib/runtime/nabl/-
  lib/runtime/analysis/-
  lib/runtime/task/-
  lib/runtime/types/-

strategies
  collect-constraint(|l, p-p): GlobalFunDef(name, params, body) ->
      ([(<try(name-resolve)> name, name-ty), params-n*, body-n*], [params-c*, body-c*])
      where params-tv := <map(fresh-var)> params
          ; body-tv   := <fresh-var>
          ; name-ty   := <foldr(!body-tv, !FuncType(<Fst>, <Snd>))> params-tv
          ; (params-n*,params-c*) := <zip(collect-constraint(|l, p-p) <+ ());filter(not(?()));unzip;(concat,concat)> (params, params-tv)
          ; (body-n*, body-c*) := <collect-constraint(|l, p-p)> (body, body-tv)
  
  collect-constraint(|l, p-p): (PatternVar(name), tv) -> ([(<try(name-resolve)> name, tv)],[])
  collect-constraint(|l, p-p): (FuncApp(f, a), tv) -> ([n1*,n2*],[c,c1*,c2*])
    where f-tv := <fresh-var>
        ; a-tv := <fresh-var>
        ; (n1*,c1*) := <collect-constraint(|l, p-p)> (f,f-tv)
        ; (n2*,c2*) := <collect-constraint(|l, p-p)> (a,a-tv)
        ; c   := CEq(f-tv, FuncType(a-tv, tv))
  collect-constraint(|l, p-p): (p@Prefix(_), tv) -> ([],[CEq(tv, <get-type> p)])
  collect-constraint(|l, p-p): (i@Int(_), tv) -> ([],[CEq(tv, <get-type> i)])
  collect-constraint(|l, p-p): (Var(gn), tv) -> ([(<name-resolve> gn, tv)], [])
  
  name-resolve: name -> uri
    where <has-annotation(?Use(u))> name
        ; Def(uri) := <task-get-results; Hd> u
  name-resolve: name -> uri
    where <has-annotation(?Def(uri))> name
  
  collect-constraints(|l, p-p): 
    Module(mp*) -> constraint*
      where constraint* := <map(collect-constraints-helper(|l, p-p))
                           ;concat
                           ;unzip
                           ;(concat,concat)> mp*
  collect-constraints-helper(|l, p-p):
  	MP(ValDef(list)) -> <map(collect-constraint(|l, p-p))> list