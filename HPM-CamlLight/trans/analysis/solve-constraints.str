module analysis/solve-constraints

imports
  include/CamlLight
  extra-constructors
  
  lib/runtime/nabl/-
  
  trans/analysis/constraints

strategies
  free-typevars = free-vars(\TypeVar(_) -> [<id>]\, fail)
  
  d(|str) = where(<debug> str)
  d'(|str) = where(!(str,<id>);debug)
  ds(s) = debug;s;debug
  
  // solve-constraints : [(name, TypeExpr, [(name, TypeExpr)], [Constraint])] -> [(name, TypeExpr)]
  // solve the given constraints, where the input is a list with
  // 1 a name,
  // 2 its type (variable),
  // 4(!) the constraints on that type
  // 3 the existentially quantified names used in those constraints
  // each of these names is universally quantified and maybe be referenced in a CRefEq in any of the constraints of that or other names. 
  solve-constraints =
    insert-existentials
  ; start-name-logging
  ; sc-done( solve-constraints'
           , ref-resolve(solve-constraints')
           , mono-rec(ref-resolve(solve-constraints'))
           , ref-resolve2(mono-rec(ref-resolve(solve-constraints')))
           , sc-fail)
  // check if done, then prettify, else continue
  sc-done(cont) = (map(binding-solved), id) < prettify-result + cont
  // same as sc-done but saves subresults in a list
  sc-done-list(cont) = (map(binding-solved), id) < \i -> [i , <prettify-result> i]\ + \i -> [i | <cont> i]\
  // a way to end the type inference with an error
  sc-fail = where(<print-failure(|"Type inference failed. ")> "")
  // same as sc-fail but for sc-done-list
  sc-fail-list: a -> [a]
    where <print-failure(|"Type inference failed. ")> ""
  
  // higher arity version of sc-done(-list)
  sc-done(c1,c2) = sc-done(c1;sc-done(c2))
  sc-done(c1,c2,c3) = sc-done(c1;sc-done(c2,c3))
  sc-done(c1,c2,c3,c4) = sc-done(c1;sc-done(c2,c3,c4))
  sc-done(c1,c2,c3,c4,c5) = sc-done(c1;sc-done(c2,c3,c4,c5))
  sc-done(c1,c2,c3,c4,c5,c6) = sc-done(c1;sc-done(c2,c3,c4,c6))
  sc-done(c1,c2,c3,c4,c5,c6,c7) = sc-done(c1;sc-done(c2,c3,c4,c6,c7))
  
  sc-done-list(c1,c2) = sc-done-list(c1;sc-done-list(c2))
  sc-done-list(c1,c2,c3) = sc-done-list(c1;sc-done-list(c2,c3))
  sc-done-list(c1,c2,c3,c4) = sc-done-list(c1;sc-done-list(c2,c3,c4))
  sc-done-list(c1,c2,c3,c4,c5) = sc-done-list(c1;sc-done-list(c2,c3,c4,c5))
  sc-done-list(c1,c2,c3,c4,c5,c6) = sc-done-list(c1;sc-done-list(c2,c3,c4,c6))
  sc-done-list(c1,c2,c3,c4,c5,c6,c7) = sc-done-list(c1;sc-done-list(c2,c3,c4,c6,c7))
  
  // start-name-logging : [(name, TypeExpr, [Constraint])] -> ([(name, TypeExpr, [Constraint])], ([(TypeExpr, Int)], [(Int,Int)]))
  start-name-logging = !(<id>, (<mapconcat(snl-helper)>, []))
  snl-helper : (name, te, c) -> [<mkCRefEq> (name, te) | c]
  
  // solve-constraints' : ([(name, TypeExpr, [Constraint])], ([(TypeExpr, Int)], [(Int,Int)])) -> ([(name, TypeExpr, [Constraint])], ([(TypeExpr, Int)], [(Int,Int)]))
  // solves constraints by:
  // 1 removing aliases (CEq(TypeVar(alias), TypeVar(var)))
  // 2 fusing constraints (CEq(TypeVar(a), b) /\ CEq(TypeVar(a), c) --> CEq(b,c))
  // 3 expanding constraints (by unifying two Equivalent ASTs up to TypeVars)
  // 4 Doing the above steps in a fixpoint
  // 5 Trying to fill in the full concrete type of the binding
  // 6 Removing any surplus constraints after doing the filling in
  solve-constraints' = thread-map( fixpoint( remove-aliases
                                           ; fuse-constraints
                                           ; expand-constraints )
                                 ; try(substitute-typevars);cull-typevars)
  
  // ref-resolve : ([(name, TypeExpr, [Constraint])], ([(TypeExpr, Int)], [(Int,Int)])) -> ([(name, TypeExpr, [Constraint])], ([(TypeExpr, Int)], [(Int,Int)]))
  // resolves names of values that have concrete types and retries solving constraints (in a fixpoint)
  ref-resolve(previous-strategy) = (fixpoint(instantiate-universals;previous-strategy), id)
  
  // ref-resolve : ([(name, TypeExpr, [Constraint])], ([(TypeExpr, Int)], [(Int,Int)])) -> ([(name, TypeExpr, [Constraint])], ([(TypeExpr, Int)], [(Int,Int)]))
  // resolves names of values even if their types are incomplete
  // (by copying the remaining constraints on it too)
  // and retries solving constraints (in a fixpoint)
  ref-resolve2(previous-strategy) = (fixpoint(instantiate-incomplete;previous-strategy), id)
  
  // mono-rec : ([(name, TypeExpr, [Constraint])], ([(TypeExpr, Int)], [(Int,Int)])) -> ([(name, TypeExpr, [Constraint])], ([(TypeExpr, Int)], [(Int,Int)]))
  // monomorphic recursion by replacing all CRefEq refering to its own binding
  // with the type found so far, without alpha-conversion of the variables!
  mono-rec(previous-strategy) = (fixpoint(instantiate-recursion;previous-strategy), id)
  
  // prettify-result : ([(name, TypeExpr, [Constraint])], ([(TypeExpr, Int)], [(Int,Int)])) -> ([(name, TypeExpr)], [(TypeExpr, Int)], [(Int,Int)])
  // removes empty constraints lists and (nabl-)resolves names if possible 
  prettify-result = where(Snd;ne-to-dot;debug);Fst;map({\(n,ty,[]) -> (<try(nabl-uri-name)> n, ty)\});try(\[s] -> s\)
  
  ne-to-dot: (n,e) ->
$[digraph g {
  [nodelist];
  [edgelist]
}]
    where
      let dot-lines = separate-by(|";");concat-strings
      in nodelist := <map-with-index(\(i,n) -> $[[i] ["["]label="[<constraint-to-string> n]"["]"]]\);dot-lines> n
       ; edgelist := <map(\(a,b)->$[[a] -> [b]]\);dot-lines> e
      end
  
  // cull-type-vars : (name, TypeExpr, [Constraint]) -> (name, TypeExpr, [Constraint])
  // remove constraints that mention unused typevars
  cull-typevars: ((n,t,l), (n*, e*)) -> ((n,t,l'), (n*, e*))
    with ttvs    := <free-typevars> t
       ; ltvs    := <filter(?CRefEq(_,_));free-typevars> l
       ; tvs     := <conc;make-set> (ttvs, ltvs)
       ; closure := <typevars-closure> (tvs, l)
       ; l'      := <filter(ct-helper(|closure))> l
  // ct-helper : (|[TypeVar]) -> Constraint -?> Constraint
  // predicate that checks CEq to have a TypeVar lhs or rhs that's in the set
  // and checks CRefEq to have at least one TypeVar in the TypeExpr that's in the set
  ct-helper(|set): CEq(t@TypeVar(_),_) -> <id>
    where <elem> (t,set)
  ct-helper(|set): CEq(_,t@TypeVar(_)) -> <id>
    where <elem> (t,set)
  ct-helper(|set): CRefEq(_,texpr) -> <id>
    where freevars := <free-typevars; make-set> texpr
        ; [_|_] := <isect> (freevars, set)
  
  // concrete-type : TypeExpr -?> TypeExpr
  // succeeds if the type is concrete and fails otherwise
  concrete-type = where(free-typevars => [])
  
  // binding-solved : (name, TypeExpr, [Constraint]) -?> (name, TypeExpr, [Constraint])
  // succeeds if all Constraints were satified
  // fails in all other cases
  binding-solved = ?(_,_,[])
  
  // typevars-closure : ([TypeVar], [Constraint]) -> [TypeVar]
  // Returns a list of (unique) typevars that can be reached (directly or
  // indirectly) through Constraints from the given TypeVar
  typevars-closure: (tvs,l) -> <foldl(typevar-closure);Fst> (tvs,(tvs,l))
  // typevar-closure: (TypeVar, ([TypeVar],[Constraint])) -> ([TypeVar],[Constraint])
  typevar-closure: (tv,(foundVars,l)) -> (closure,l)
    with relevantCs  := <filter(tc-helper1(|tv))> l
       ; freeVars    := <free-vars(tc-helper2(|tv), fail);make-set> relevantCs
       ; newVars     := <diff> (freeVars, foundVars)
       ; foundVars'  := <union> (foundVars, freeVars)
       ; (closure,l) := <foldl(typevar-closure)> (newVars,(foundVars',l))
  tc-helper1(|tv) = ?CEq(tv,_) + ?CEq(_,tv) + ?CRefEq(_,tv)
  tc-helper2(|tv): t@TypeVar(_) -> [t] where <not(eq)>(t,tv)
  
  // substitute-typevars : (name, TypeExpr, [Constraint]) -?> (name, TypeExpr, [Constraint])
  // Substitute type variables in the constraints for the equivalent type expressions founds,
  // then substitute the type variable in the type of the name-binding (the second value in the 3-tuple input)
  // These substitution are only done when the CEq constraint is not recursive,
  // i.e. only for CEq(tv@TypeVar(_), b) where "tv is not somewhere in b"
  substitute-typevars: ((n,t,l), (n*, e*)) -> ((n,t',l'), (n*, e*))
    where dict := <filter(typevar-first;unCEq)> l
        ; l' := <map(try(CEq(?TypeVar(_),outermost(st-helper(|dict)))))> l
        ; dict' := <filter(typevar-first;unCEq)> l'
        ; t' := <alltd(st-helper(|dict'))> t
  st-helper(|dict): tv@TypeVar(_) -> <lookup;not(oncetd(?tv))> (tv, dict)
  
  // refresh-vars : a -> a
  // alpha-conversion of the typevariables to give each unique one a fresh name
  // doesn't take any context into account
  refresh-vars: t -> t'
    with vars := <free-typevars> t
       ; dict := <map(!(<id>, <fresh-var>))> vars
       ; t' := <alltd({tv:?tv@TypeVar(_);<lookup> (tv, dict)})> t
  
  // instantiate-universals : [(name, TypeExpr, [Constraint])] -> [(name, TypeExpr, [Constraint])]
  // instantiate universally quantified type variables that have been fully resolved
  instantiate-universals: l -> l'
    with dict := <filter(iu-helper1)> l
       ; l' := <map((id,id,map(try(iu-helper2(|dict)))))> l
  iu-helper1: (n,t,_)  -> (n,t) where <concrete-type> t
  iu-helper1: (n,t,[]) -> (n,t)
  iu-helper2(|dict): CRefEq(uri,ty) -> <mkCEq>(<lookup;refresh-vars>(uri,dict),ty)
  
  // instantiate-incomplete : [(name, TypeExpr, [Constraint])] -> [(name, TypeExpr, [Constraint])]
  // instantiate universally quantified type variables even if their types are incomplete
  // (by copying the remaining constraints on it too)
  instantiate-incomplete: l -> l'
    with dict := <map(ii-helper1)> l
       ; l' := <map((id,id,mapconcat(ii-helper2(|dict))))> l
  ii-helper1: (n,t,c)  -> (n,(t,c))
  ii-helper2(|dict) = \CRefEq(uri,ty) -> [<mkCEq>(t,ty) | c]
      where (t,c) := <lookup;refresh-vars> (uri,dict)\
    <+ ![<id>]
  
  instantiate-recursion = map(instantiate-recursion')
  // instantiate-recursion : (name, TypeExpr, [Constraint]) -> (name, TypeExpr, [Constraint])
  // takes all references to the binding and replaces them
  // with the type of the binding as found so far, without alpha-converting the variables in it
  instantiate-recursion': (n,t,l) -> (n,t,l')
    with l' := <map(ir-helper(|n,t))> l
  ir-helper(|n,t): CEq(_,_) -> <id>
  ir-helper(|n,t): CRefEq(n,te) -> <mkCEq> (t,te)
  ir-helper(|n,t): CRefEq(n',_) -> <id> where <not(eq)> (n,n')
  
  insert-existentials = map(insert-existentials')
  // insert-existentials' : (name, TypeExpr, [(name, TypeExpr)], [Constraint]) -> (name, TypeExpr, [Constraint])
  // Changes CRefEq to CEq is the reference is to an existentially quantified type variable
  insert-existentials': (u-name, u-type, existentials, constraints) -> (u-name, u-type, constraints')
    with constraints' := <alltd(ie-helper(|existentials))> constraints
  ie-helper(|existentials): CRefEq(uri, ty) -> <mkCEq> (ty, ty') where ty' := <lookup> (uri, existentials)
  
  // remove-aliases : ((name, TypeExpr, [Constraint]), ([(TypeExpr, Int)], [(Int,Int)])) -> ((name, TypeExpr, [Constraint]), ([(TypeExpr, Int)], [(Int,Int)]))
  // finds and removes constraints of the form CEq(TypeVar(a), TypeVar(b)) by replacing all instances of a with b
  remove-aliases: ((nm, t, l), (n, e)) -> ((nm, t', l''), (n''', e'''))
    with (alias,l') := <partition(?CEq(TypeVar(_),TypeVar(_)))> l
       ; (((), (), alias'), (n', e')) := <fuse-constraints> (((), (), alias), (n, e))
       ; (l'', n'', e'') := <foldl(ra-helper)> (alias',(l',n',e'))
       ; (t',n''',e''')  := <foldl(ra-helper)> (alias',(t,n'',e''))
  ra-helper: (a@CEq(tv1,tv2),(c,n,e)) -> (c', n', e')
    with c' := <alltd(?tv1;!tv2)> c
       ; if <eq> (c,c')
           then (n',e') := (n,e)
           else ai := <get-index>(a,n)
              ; if <is-list> c'
                  then (n',e') := <foldl(rah(|ai))> (<zip> (c,c'), (n,e))
                  else (n',e') := <rah(|ai)> ((c,c'), (n,e))
                end
         end
  rah(|ai): ((c,c'),(n,e)) -> (n', e')
    with if <not(get-index)> (c', n)
           then n' := <conc> (n,[c'])
              ; ci := <get-index>(c,n)
              ; i  := <get-index> (c',n')
              ; e' := <conc> (e,[(ai,i), (ci,i)])
           else n' := n
              ; e' := e
         end

  // fuse-constraints : ((name, TypeExpr, [Constraint]), ([(TypeExpr, Int)], [(Int,Int)])) -> ((name, TypeExpr, [Constraint]), ([(TypeExpr, Int)], [(Int,Int)]))
  // makes sure all equality constraints with top-level type vars have the type var first,
  // then fuses constraints that start with the same left-hand side typevariable. 
  fuse-constraints: ((nm, t, c), (n, e)) -> ((nm, t, c''), (n', e'))
    with c'  := <map(typevar-first)> c
       ; (c'',n',e') := <foldl(fc-helper <+ Snd)> (c',(c',n,e))
  // fc-helper : (Constraint, [Constraint]) -?> [Constraint]
  // when two or more equivalence constraints start with the same typevariable,
  // generate constraints that all right-hand sides are equivalent
  fc-helper: (CEq(tv@TypeVar(_),_),(l, n, e)) -> (l', n'', e'')
    where (eqs,rest) := <partition(one(?tv))> l
        ; <min-length(|2)> eqs
    with new := <mapconcat(fch-1(|n));filter((not(?tv),id))> eqs
       ; uniqueNew := <fch-2
                      ;try(\[_] -> []\)
                      ;consecutive-pairs(fch-4)
                      ;filter(where(?(a,_);!n;not(fetch(?a))))> new
       ; new' := <unzip;Fst> uniqueNew
       ; n' := <conc> (n,new')
       ; e' := <conc> (e, <mapconcat(fch-3(|n'))> uniqueNew)
       ; (((),(),new''),(n'',e'')) := <!(((),(),<id>), (n',e'));expand-constraints> new'
       ; l' := <union> ([<Hd> eqs|rest], new'')
  
  fch-1(|n): c -> <map(!(<id>,i))> a
    with i  := <get-index> (c,n)
       ; a := <get-arguments> c

  fch-2: [(a,b)|t] -> [(a, b') | t']
    with b' := <uniq> [b | <filter(?(a,_);?(_,<id>))> t]
       ; t' := <filter(not(?(a,_)))> t

  fch-3(|n'): (c,p*) -> <map(\p -> (p,i)\)> p*
    with i := <get-index> (c,n')
  
  fch-4: ((a,b*),(c,d*)) -> (<mkCEq>(a,c),[b*,d*])
  
  // expand-constraints : ((name, TypeExpr, [Constraint]), ([(TypeExpr, Int)], [(Int,Int)])) -> ((name, TypeExpr, [Constraint]), ([(TypeExpr, Int)], [(Int,Int)]))
  // helper for expand-constraint
  expand-constraints: ((n,t,c), gr) -> ((n,t,c''), gr')
    with (c', gr') := <thread-map(expand-constraint)> (c, gr)
       ; c'' := <concat> c'
  // expand-constraint : (Constraint, ([(TypeExpr, Int)], [(Int,Int)])) -> ([Constraint], ([(TypeExpr, Int)], [(Int,Int)]))
  // Expands equality by unifying inner type variables.
  // Uses print-failure when it finds two distinct concrete types.
  expand-constraint: (c@CEq(t1,t2), (n,e)) -> (c',(n',e'))
    with c' := <unify'(?TypeVar(_));map(mkCEq)> (t1,t2)
       ; newc := <diff> (c', n)
       ; if <?[]> newc
           then (n',e') := (n,e)
           else n' := <conc> (n,newc)
              ; i  := <get-index> (c,n)
              ; e' := <conc> (e,<map(\c -> (i, <get-index> (c,n'))\)> newc)
         end
  expand-constraint: (c@CRefEq(_,_),gr) -> ([c],gr)
  expand-constraint: CEq(ConstrType(_, n),ConstrType(_, n')) ->
    <print-failure(|$[Failed to match [n] with [n']: ])>
    where <not(?n)> n'
  
  // simple unification 
  // The builtin unify strategy fails on input like [(TypeVar(a),FuncType(TypeVar(a),TypeVar(b)))]
  // because tries find the most general unifier
  unify'(isvar) = \(a@c#(as),b@c#(bs)) -> <zip(unify'(isvar));concat> (as,bs)
    where <not(isvar)> a; <not(isvar)> b\ <+ \(a,b) -> [<id>]\
  