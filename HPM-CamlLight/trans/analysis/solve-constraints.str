module analysis/solve-constraints

imports
  include/CamlLight
  extra-constructors
  
  lib/runtime/nabl/-
  
  trans/analysis/constraints

strategies
  solve-constraints = map( insert-existentials
                         ; fixpoint(remove-aliases;(id,id,fuse-constraints;expand-constraints))
                         ; try(sc-helper1) <+ print-failure(|"Unable to resolve type constraints further: "))
  sc-helper1: (n,t,l) -> (n',t',l')
    where l' := <map(CEq(?TypeVar(_),outermost(sc-helper2(|l))))> l
        ; n' := <try(nabl-uri-name)> n
        ; t' := <sc-helper2(|l')> t
  sc-helper2(|dict): TypeVar(_) -> <lookup>(<id>, <map(unCEq)> dict)
  
  insert-existentials: (u-name, u-type, existentials, constraints) -> (u-name, u-type, constraints')
    where constraints' := <alltd(ie-helper(|existentials))> constraints
  ie-helper(|existentials): CRefEq(uri, ty) -> <mkCEq> (ty, ty') where ty' := <lookup> (uri, existentials)
  
  remove-aliases: (n, t, l) -> (n, t', l'')
    where (alias,l') := <partition(?CEq(TypeVar(_),TypeVar(_)))> l
        ; alias'     := <fuse-constraints> alias
        ; l''  := <foldl(ra-helper)> (alias',l')
        ; [t'] := <foldl(ra-helper)> (alias',[t])
  ra-helper: ((tv1,tv2),c*) -> <map(alltd(?tv1;!tv2))> c*

  fuse-constraints: c -> <foldl(fc-helper <+ Snd)> (c',c')
    where c' := <map(typevar-first)> c
  
  fc-helper: (CEq(tv@TypeVar(_),_),l) -> res
    where (eqs,rest) := <partition(one(?tv))> l
        ; <min-length(|2)> eqs
        ; res := <conc> ([<Hd> eqs|rest], <mapconcat(get-arguments)
							                            ;filter(not(?tv))
							                            ;nub;try(\[_] -> []\)
							                            ;consecutive-pairs(mkCEq)
							                            ;expand-constraints> eqs)
  
  expand-constraints = mapconcat(expand-constraint)

  expand-constraint: CEq(t1,t2) -> <unify(?TypeVar(_));map(mkCEq)> [(t1,t2)]
  expand-constraint: CEq(ConstrType(_, n),ConstrType(_, n')) ->
    <print-failure(|$[Failed to match [n] with [n']: ])> where <not(?n)> n'
  