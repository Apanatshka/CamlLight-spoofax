module analysis/solve-constraints

imports
  include/CamlLight
  extra-constructors
  
  lib/runtime/nabl/-
  
  trans/analysis/constraints

strategies
  free-typevars = free-vars(\TypeVar(_) -> [<id>]\, fail)
  
  d(|str) = where(<debug> str)
  d'(|str) = where(!(str,<id>);debug)
  ds(s) = debug;s;debug
  
  // solve-constraints : [(name, TypeExpr, [(name, TypeExpr)], [Constraint])] -> [(name, TypeExpr)]
  // solve the given constraints, where the input is a list with
  // 1 a name,
  // 2 its type (variable),
  // 4(!) the constraints on that type
  // 3 the existentially quantified names used in those constraints
  // each of these names is universally quantified and maybe be referenced in a CRefEq in any of the constraints of that or other names. 
	solve-constraints =
		insert-existentials
	; sc-done( solve-constraints'
	         , ref-resolve(solve-constraints')
	         , mono-rec(ref-resolve(solve-constraints'))
           , sc-fail)
	// check if done, then prettify, else continue
  sc-done(cont) = map(binding-solved) < prettify-result + cont
  // same as sc-done but saves subresults in a list
  sc-done-list(cont) = map(binding-solved) < \i -> [i , <prettify-result> i]\ + \i -> [i | <cont> i]\
  // a way to end the type inference with an error
  sc-fail: a -> a
    where <print-failure(|"Type inference failed. ")> ""
  // same as sc-fail but for sc-done-list
  sc-fail-list: a -> [a]
    where <print-failure(|"Type inference failed. ")> ""
  
  // higher arity version of sc-done(-list)
  sc-done(c1,c2) = sc-done(c1;sc-done(c2))
  sc-done(c1,c2,c3) = sc-done(c1;sc-done(c2,c3))
  sc-done(c1,c2,c3,c4) = sc-done(c1;sc-done(c2,c3,c4))
  sc-done(c1,c2,c3,c4,c5) = sc-done(c1;sc-done(c2,c3,c4,c5))
  sc-done(c1,c2,c3,c4,c5,c6) = sc-done(c1;sc-done(c2,c3,c4,c6))
  sc-done(c1,c2,c3,c4,c5,c6,c7) = sc-done(c1;sc-done(c2,c3,c4,c6,c7))
  
  sc-done-list(c1,c2) = sc-done-list(c1;sc-done-list(c2))
  sc-done-list(c1,c2,c3) = sc-done-list(c1;sc-done-list(c2,c3))
  sc-done-list(c1,c2,c3,c4) = sc-done-list(c1;sc-done-list(c2,c3,c4))
  sc-done-list(c1,c2,c3,c4,c5) = sc-done-list(c1;sc-done-list(c2,c3,c4,c5))
  sc-done-list(c1,c2,c3,c4,c5,c6) = sc-done-list(c1;sc-done-list(c2,c3,c4,c6))
  sc-done-list(c1,c2,c3,c4,c5,c6,c7) = sc-done-list(c1;sc-done-list(c2,c3,c4,c6,c7))
  
  // solve-constraints' : (name, TypeExpr, [Constraint]) -> (name, TypeExpr, [Constraint])
  // solves constraints by:
  // 1 removing aliases (CEq(TypeVar(alias), TypeVar(var)))
  // 2 fusing constraints (CEq(TypeVar(a), b) /\ CEq(TypeVar(a), c) --> CEq(b,c))
  // 3 expanding constraints (by unifying two Equivalent ASTs up to TypeVars)
  // 4 Doing the above steps in a fixpoint
  // 5 Trying to fill in the full concrete type of the binding
  // 6 Removing any surplus constraints after doing the filling in
  solve-constraints' = map( fixpoint( remove-aliases
                                    ; (id,id, fuse-constraints
                                            ; expand-constraints))
                          ; try(substitute-typevars);cull-typevars)
  
  // ref-resolve : [(name, TypeExpr, [Constraint])] -> [(name, TypeExpr, [Constraint])]
  // resolves names of values that have concrete types and retries solving constraints (in a fixpoint)
  ref-resolve(previous-strategy) = fixpoint(instantiate-universals;previous-strategy)
  
  // mono-rec : [(name, TypeExpr, [Constraint])] -> [(name, TypeExpr, [Constraint])]
  // monomorphic recursion by replacing all CRefEq refering to its own binding
  // with the type found so far, without alpha-conversion of the variables!
  mono-rec(previous-strategy) = fixpoint(instantiate-recursion;previous-strategy)
  
  // prettify-result : [(name, TypeExpr, [Constraint])] -> [(name, TypeExpr)]
  // removes empty constraints lists and (nabl-)resolves names if possible 
  prettify-result = map({\(n,ty,[]) -> (<try(nabl-uri-name)> n, ty)\});try(\[s] -> s\)
  
  // cull-type-vars : (name, TypeExpr, [Constraint]) -> (name, TypeExpr, [Constraint])
  // remove constraints that mention unused typevars
  cull-typevars: (n,t,l) -> (n,t,l')
    with ttvs    := <free-typevars> t
       ; ltvs    := <filter(?CRefEq(_,_));free-typevars> l
       ; tvs     := <conc;make-set> (ttvs, ltvs)
       ; closure := <typevars-closure> (tvs, l)
       ; l'      := <filter(ct-helper(|closure))> l
  // ct-helper : (|[TypeVar]) -> Constraint -?> Constraint
  // predicate that checks CEq to have a TypeVar lhs or rhs that's in the set
  // and checks CRefEq to have at least one TypeVar in the TypeExpr that's in the set
  ct-helper(|set): CEq(t@TypeVar(_),_) -> <id>
    where <elem> (t,set)
  ct-helper(|set): CEq(_,t@TypeVar(_)) -> <id>
    where <elem> (t,set)
  ct-helper(|set): CRefEq(_,texpr) -> <id>
    where freevars := <free-typevars; make-set> texpr
        ; [_|_] := <isect> (freevars, set)
  
  // concrete-type : TypeExpr -?> TypeExpr
  // succeeds if the type is concrete and fails otherwise
  concrete-type = where(free-typevars => [])
  
  // binding-solved : (name, TypeExpr, [Constraint]) -?> (name, TypeExpr, [Constraint])
  // succeeds if all Constraints were satified
  // fails in all other cases
  binding-solved = ?(_,_,[])
  
  // typevars-closure : ([TypeVar], [Constraint]) -> [TypeVar]
  // Returns a list of (unique) typevars that can be reached (directly or
  // indirectly) through Constraints from the given TypeVar
  typevars-closure: (tvs,l) -> <foldl(typevar-closure);Fst> (tvs,(tvs,l))
  // typevar-closure: (TypeVar, ([TypeVar],[Constraint])) -> ([TypeVar],[Constraint])
  typevar-closure: (tv,(foundVars,l)) -> (closure,l)
    with relevantCs  := <filter(tc-helper1(|tv))> l
       ; freeVars    := <free-vars(tc-helper2(|tv), fail);make-set> relevantCs
       ; newVars     := <diff> (freeVars, foundVars)
       ; foundVars'  := <union> (foundVars, freeVars)
       ; (closure,l) := <foldl(typevar-closure)> (newVars,(foundVars',l))
  tc-helper1(|tv) = ?CEq(tv,_) + ?CEq(_,tv) + ?CRefEq(_,tv)
  tc-helper2(|tv): t@TypeVar(_) -> [t] where <not(eq)>(t,tv)
  
  // substitute-typevars : (name, TypeExpr, [Constraint]) -> (name, TypeExpr, [Constraint])
  // Substitute type variables in the constraints for the equivalent type expressions founds,
  // then substitute the type variable in the type of the name-binding (the second value in the 3-tuple input)
  // These substitution are only done when the CEq constraint is not recursive,
  // i.e. only for CEq(tv@TypeVar(_), b) where "tv is not somewhere in b"
  substitute-typevars: (n,t,l) -> (n,t',l')
    where dict := <filter(typevar-first;unCEq)> l
        ; l' := <map(try(CEq(?TypeVar(_),outermost(st-helper(|dict)))))> l
        ; dict' := <filter(typevar-first;unCEq)> l'
        ; t' := <alltd(st-helper(|dict'))> t
  st-helper(|dict): tv@TypeVar(_) -> <lookup;not(oncetd(?tv))> (tv, dict)
  
  // refresh-vars : TypeExpr -> TypeExpr
  // alpha-conversion of the typevariables to give each unique one a fresh name
  // doesn't take any context into account
  refresh-vars: t -> t'
    with vars := <free-typevars> t
       ; dict := <map(!(<id>, <fresh-var>))> vars
       ; t' := <alltd({tv:?tv@TypeVar(_);<lookup> (tv, dict)})> t
  
  // instantiate-universals : [(name, TypeExpr, [Constraint])] -> [(name, TypeExpr, [Constraint])]
  // instantiate universally quantified type variables that have been fully resolved
  instantiate-universals: l -> l'
    with dict := <filter(iu-helper1)> l
       ; l' := <map(alltd(iu-helper2(|dict)))> l
  iu-helper1: (n,t,_)  -> (n,t) where <concrete-type> t
  iu-helper1: (n,t,[]) -> (n,t)
  iu-helper2(|dict): CRefEq(uri,ty) -> <mkCEq>(<lookup;refresh-vars>(uri,dict),ty)
  
  instantiate-recursion = map(instantiate-recursion')
  // instantiate-recursion : (name, TypeExpr, [Constraint]) -> (name, TypeExpr, [Constraint])
  // takes all references to the binding and replaces them
  // with the type of the binding as found so far, without alpha-converting the variables in it
  instantiate-recursion': (n,t,l) -> (n,t,l')
    where l' := <map(ir-helper(|n,t))> l
  ir-helper(|n,t): CEq(_,_) -> <id>
  ir-helper(|n,t): CRefEq(n,te) -> <mkCEq> (t,te)
  ir-helper(|n,t): CRefEq(n',_) -> <id> where <not(eq)> (n,n')
  
  insert-existentials = map(insert-existentials')
  // insert-existentials' : (name, TypeExpr, [(name, TypeExpr)], [Constraint]) -> (name, TypeExpr, [Constraint])
  // Changes CRefEq to CEq is the reference is to an existentially quantified type variable
  insert-existentials': (u-name, u-type, existentials, constraints) -> (u-name, u-type, constraints')
    with constraints' := <alltd(ie-helper(|existentials))> constraints
  ie-helper(|existentials): CRefEq(uri, ty) -> <mkCEq> (ty, ty') where ty' := <lookup> (uri, existentials)
  
  // remove-aliases : (name, TypeExpr, [Constraint]) -> (name, TypeExpr, [Constraint])
  // finds and removes constraints of the form CEq(TypeVar(a), TypeVar(b)) by replacing all instances of a with b
  remove-aliases: (n, t, l) -> (n, t', l'')
    where (alias,l') := <partition(?CEq(TypeVar(_),TypeVar(_)))> l
        ; alias'     := <fuse-constraints> alias
        ; l''  := <foldl(ra-helper)> (alias',l')
        ; [t'] := <foldl(ra-helper)> (alias',[t])
  ra-helper: ((tv1,tv2),c*) -> <map(alltd(?tv1;!tv2))> c*

  // fuse-constraints : [Constraint] -> [Constraint]
  // makes sure all equality constraints with top-level type vars have the type var first,
  // then fuses constraints that start with the same left-hand side typevariable. 
  fuse-constraints: c -> <foldl(fc-helper <+ Snd)> (c',c')
    with c' := <map(typevar-first)> c
  // fc-helper : (Constraint, [Constraint]) -> [Constraint]
  // when two or more equivalence constraints start with the same typevariable,
  // generate constraints that all right-hand sides are equivalent
  fc-helper: (CEq(tv@TypeVar(_),_),l) -> res
    where (eqs,rest) := <partition(one(?tv))> l
        ; <min-length(|2)> eqs
    with res := <conc> ([<Hd> eqs|rest], <mapconcat(get-arguments)
                                         ;filter(not(?tv))
                                         ;nub;try(\[_] -> []\)
                                         ;consecutive-pairs(mkCEq)
                                         ;expand-constraints> eqs)
  
  // expand-constraints : [Constraint] -> [Constraint]
  // helper for expand-constraint
  expand-constraints = mapconcat(expand-constraint)
  // expand-constraint : Constraint -> [Constraint]
  // Expands equality by unifying inner type variables.
  // Uses print-failure when it finds two distinct concrete types.
  expand-constraint: CEq(t1,t2)  -> <unify'(?TypeVar(_));map(mkCEq)> (t1,t2)
  expand-constraint: CRefEq(_,_) -> [<id>]
  expand-constraint: CEq(ConstrType(_, n),ConstrType(_, n')) ->
    <print-failure(|$[Failed to match [n] with [n']: ])>
    where <not(?n)> n'
  
  // simple unification 
  // The builtin unify strategy fails on input like [(TypeVar(a),FuncType(TypeVar(a),TypeVar(b)))]
  // because tries find the most general unifier
  unify'(isvar) = \(a@c#(as),b@c#(bs)) -> <zip(unify'(isvar));concat> (as,bs)
    where <not(isvar)> a; <not(isvar)> b\ <+ \(a,b) -> [<id>]\
  