module cfs/Patterns

imports
	lex/Identifier
	cfs/Types
	cfs/Values

context-free start-symbols
	Pattern

template options
	tokenize: "[("
	keyword -/- [A-Za-z]

templates
	
	PatternRecordBinding.PatternRecordB = [[GLOBALNAME] = [Pattern]]
	
	// ambiguity with Constant is actually *wanted*
	Pattern.PatternVar     = [[IDENT]]
	Pattern                = [[Constant]]
	Pattern.Wildcard       = [_]
	Pattern.Alias          = [[Pattern] as [IDENT]]
	Pattern                = [([Pattern])] {bracket}
	Pattern.HasTypePattern = [([Pattern] : [TypeExpr])]
	Pattern.PatternChoice  = [[Pattern] | [Pattern]] {left}
	Pattern.RecordPattern  = [{[PatternRecordBinding+; separator="; "]}]
	Pattern.ConstrPattern  = [[NCConstr] [Pattern]]
	// Already attained through PatternConstant:
	// Pattern.EmptyListPattern     = <[]>
	Pattern.ListLitPattern    = <[<Pattern+; separator="; ">]>
	Pattern.ConsListPattern   = [[Pattern] :: [Pattern]] {right}
	// avoid removes the case of one Pattern already being a TuplePattern, non-assoc should remove the other ambiguities but doesn't right now so I've added the priorities myself
	Pattern.TuplePattern      = [[TuplePattern]]// {avoid}//, non-assoc}
	
context-free priorities
	Pattern.ConstrPattern   >
	Pattern.ConsListPattern >
	Pattern.TuplePattern    >
	Pattern.PatternChoice   >
	Pattern.Alias

  context-free syntax
    Pattern "," Pattern      -> TuplePattern {ast("[<1>,<2>]")}
    Pattern "," TuplePattern -> TuplePattern {ast("<conc([<1>],<2>)>")}

  context-free priorities
  	Pattern "," Pattern -> TuplePattern >
    TuplePattern -> Pattern
  context-free priorities
  	Pattern "," TuplePattern -> TuplePattern >
    TuplePattern -> Pattern

// // These should preferably be generated because of the non-assoc annotation on Pattern.TuplePattern, but that isn't the case right now. 
// context-free priorities
// 	Pattern -> {Pattern ","}+ >
// 	{Pattern ","}+ -> Pattern
