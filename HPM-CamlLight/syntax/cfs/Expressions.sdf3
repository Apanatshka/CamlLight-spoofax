module cfs/Expressions

imports
	lex/Identifier
	lex/Number
	lex/Text
	cfs/Names
	cfs/Values
	cfs/Types
	cfs/Patterns

context-free start-symbols
	Expr

context-free syntax
	Expr "," Expr      -> TupleExpr {ast("[<1>,<2>]")}
	Expr "," TupleExpr -> TupleExpr {ast("<conc([<1>],<2>)>")}

template options
	keyword -/- [A-Za-z0-9]

templates
	ExprRecordBinding.ExprRecordB = [[GLOBALNAME] = [Expr]]
	
	//this is probably a mistake in the manual because it isn't explained and it's ambiguous with Variable
	// Expr.Ident               = [[IDENT]]
	// ambiguity with Constant is actually *wanted*
	Expr = [[Variable]]
	Expr = [[Constant]]
	Expr = [([Expr])] {bracket}
	Expr = [begin
	[Expr]
end] {bracket}
	Expr.HasType   = [([Expr]: [TypeExpr])]
	Expr.TupleExpr = [[TupleExpr]]
	// NCConstr pattern is ambiguous with function application. Only the following special case is specified: 
	Expr.ConstrApp    = [[NCConstr] [Expr]]
	Expr.ListLit      = <[<Expr+; separator="; ">]>
	Expr.ArrayLit     = <[|<Expr+; separator="; ">|]>
	Expr.RecordExpr   = [{[ExprRecordBinding+; separator="; "]}]
	Expr.FuncApp      = [[Expr] [Expr]] {left}
	Expr.RecordAccess = [[Expr].[GLOBALNAME]]
	// <- may be read as LessThan(Negate(...)), hence the prefer
	Expr.RecordAssign = [[Expr].[GLOBALNAME] <- [Expr]] {right, prefer}
	Expr.ArrayAccess  = [[Expr].([Expr])]
	// <- may be read as LessThan(Negate(...)), hence the prefer
	Expr.ArrayAssign  = [[Expr].([Expr]) <- [Expr]] {right, prefer}
	// prefer so the dangling else is associated with the last if
	Expr.IfExpr       = [if [Expr] then [Expr]] {prefer}
	Expr.IfElseExpr   = [if [Expr] then [Expr] else [Expr]]
	Expr.WhileExpr    = [while [Expr] do [Expr] done]
	Expr.ForExpr      = [for [IDENT] = [ForRange] do [Expr] done]
	Expr.MatchExpr    = [match [Expr] with [SimpleMatching]]
	Expr.FunDef       = [fun [MultipleMatching]]
	Expr.FunctionDef  = [function [SimpleMatching]]
	Expr.TryExpr      = [try [Expr] with [SimpleMatching]]
	Expr.LetExpr      = [let [LetBind+; separator="\nand "] in [Expr]]
	Expr.LetRecExpr   = [let rec [LetRecBind+; separator="\nand "] in [Expr]]
	
	OneMatching.OneMatching     = [[Pattern] -> [Expr]]
	MultiMatching.MultiMatching = [[Pattern+; separator=" "] -> [Expr]]
	SimpleMatching              = [[OneMatching+; separator="\n| "]]
	MultipleMatching            = [[MultiMatching+; separator="\n| "]]
	LetBinding.ValDef           = [[Pattern] = [Expr]]
	// prefer over the above let binding with a ConstrPattern 
	LetBinding.FunDef           = [[Variable] [Pattern+; separator=" "] = [Expr]] {prefer}
	
	LetBind.LocalLetBind              = [[LetBinding]] 
	LetRecBind.LocalRecLetBind        = [[LetBinding]]
	GlobalLetBind.GlobalLetBind       = [[LetBinding]]
	GlobalRecLetBind.GlobalRecLetBind = [[LetBinding]]
	
	ForRange.RangeTo     = [[Expr] to [Expr]]
	ForRange.RangeDownTo = [[Expr] downto [Expr]]
	
	// avoid in favour of negative integer literals
	Expr.Negate        = [-[Expr]]  {avoid}
	Expr.FloatNegate   = [-.[Expr]]
	Expr.Dereference   = [![Expr]]
	Expr.LogicalNot    = [not [Expr]]
	
	Expr.ConsExpr      = [[Expr] :: [Expr]] {right}
	Expr.LogicalAnd    = [[Expr] & [Expr]]  {left}
	Expr.LogicalOr     = [[Expr] or [Expr]] {left}
	Expr.ExprSequence  = [[Expr]; [Expr]]   {right}

	Expr.Add             = [[Expr] + [Expr]]   {left}
	// prefer over function application of negative number
	Expr.Subtract        = [[Expr] - [Expr]]   {left, prefer}
	Expr.Multiply        = [[Expr] * [Expr]]   {left}
	Expr.Division        = [[Expr] / [Expr]]   {left}
	Expr.Modulo          = [[Expr] mod [Expr]] {left}
	Expr.FloatAdd        = [[Expr] +. [Expr]]  {left}
	// prefer over function application of float negative number
	Expr.FloatSubtract   = [[Expr] -. [Expr]]  {left, prefer}
	Expr.FloatMultiply   = [[Expr] *. [Expr]]  {left}
	Expr.FloatDivision   = [[Expr] /. [Expr]]  {left}
	Expr.FloatPowerOf    = [[Expr] ** [Expr]]  {right}
	Expr.ListConcat      = [[Expr] @ [Expr]]   {right}
	Expr.StringConcat    = [[Expr] ^ [Expr]]   {right}
	//this one isn't explained in the manual!
	//Expr.UndefinedOperator = [[Expr] ! [Expr]]
	Expr.ReferenceAssign = [[Expr] := [Expr]]  {right}
	
	//avoid because = is also used in let and record bindings
	Expr.StructuralEquals       = [[Expr] = [Expr]]   {left, avoid}
	Expr.StructuralInequals     = [[Expr] <> [Expr]]  {left}
	Expr.PhysicalEquals         = [[Expr] == [Expr]]  {left}  
	Expr.PhysicalInequals       = [[Expr] != [Expr]]  {left}  
	Expr.LessThan               = [[Expr] < [Expr]]   {left}
	Expr.LessThanEquals         = [[Expr] <= [Expr]]  {left}
	Expr.GreaterThan            = [[Expr] > [Expr]]   {left}
	Expr.GreaterThanEquals      = [[Expr] >= [Expr]]  {left}
	Expr.FloatLessThan          = [[Expr] <. [Expr]]  {left} 
	Expr.FloatLessThanEquals    = [[Expr] <=. [Expr]] {left}
	Expr.FloatGreaterThan       = [[Expr] >. [Expr]]  {left} 
	Expr.FloatGreaterThanEquals = [[Expr] >=. [Expr]] {left}

context-free priorities
	Expr.Dereference > {
		Expr.RecordAccess
		Expr.ArrayAccess
	} >
	Expr.FuncApp >
	Expr.ConstrApp > {
		Expr.Negate
		Expr.FloatNegate
	} >
	Expr.FloatPowerOf >
	Expr.Modulo > {
		Expr.Multiply
		Expr.FloatMultiply
		Expr.Division
		Expr.FloatDivision
	} > {
		Expr.Add
		Expr.FloatAdd
		Expr.Subtract
		Expr.FloatSubtract
	} >
	Expr.ConsExpr > {
		Expr.ListConcat
		Expr.StringConcat
	} > {
		Expr.StructuralEquals   
		Expr.StructuralInequals 
		Expr.PhysicalEquals     
		Expr.PhysicalInequals   
		Expr.LessThan           
		Expr.LessThanEquals   
		Expr.GreaterThan        
		Expr.GreaterThanEquals
		Expr.FloatLessThan      
		Expr.FloatLessThanEquals   
		Expr.FloatGreaterThan        
		Expr.FloatGreaterThanEquals
	} >
	Expr.LogicalNot >
	Expr.LogicalAnd >
	Expr.LogicalOr >
	Expr.TupleExpr > {
		Expr.RecordAssign
		Expr.ArrayAssign
		Expr.ReferenceAssign
	} > {
		Expr.IfExpr
		Expr.IfElseExpr
	} >
	Expr.ExprSequence > {
		Expr.LetExpr     
		Expr.LetRecExpr  
		Expr.MatchExpr   
		Expr.FunDef    
		Expr.FunctionDef 
		Expr.TryExpr     
	}

// disambiguation: Keep expression sequence from being considered inside list/array/record literals
context-free priorities
    { Expr -> {Expr ";"}+
      GLOBALNAME "=" Expr -> ExprRecordBinding } >
    Expr ";" Expr -> Expr

context-free priorities
	Expr "," Expr -> TupleExpr >
	TupleExpr -> Expr
context-free priorities
	Expr "," TupleExpr -> TupleExpr >
	TupleExpr -> Expr

// // These should preferably be generated because of the non-assoc annotation on Expr.TupleExpr, but that isn't the case right now. 
// context-free priorities
// 	Expr -> {Expr ","}+ >
// 	{Expr ","}+ -> Expr